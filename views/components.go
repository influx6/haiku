package views

import (
	"fmt"
	"html/template"

	"github.com/influx6/flux"
)

// Blueprints interface defines the interface for componet makers
type Blueprints interface {
	View(interface{}, *ViewStrategy) Components
	AndView(bind interface{}, vs *ViewStrategy, subt *template.Template) (Components, error)
	BuildView(interface{}, *ViewStrategy, bool) Components
	BuildAndView(interface{}, *ViewStrategy, *template.Template, bool) (Components, error)
	Type() string
}

// Blueprint defines the component blueprint that it generates, like setting the
// building blocks that make up a components behaviour
type Blueprint struct {
	format  *template.Template
	bluetag string
}

// NewBlueprint returns a new blueprint instance
func NewBlueprint(id string, t *template.Template) *Blueprint {
	bp := Blueprint{
		format:  t,
		bluetag: id,
	}

	return &bp
}

// Type returns the tagname type of the components generated by this blueprint
func (b *Blueprint) Type() string {
	return b.bluetag
}

// View builds up a blueprint with the arguments, the name tag giving to the
// underline view is modded with the blueprint type name + a 5-length random string
// to make it unique in the state machines. All reactive binding are automatically bounded to the view.
func (b *Blueprint) View(bind interface{}, vs *ViewStrategy) Components {
	return b.BuildView(bind, vs, true)
}

// AndView creates a new component with a combined template if supplied i.e the parsetree of the
// Blueprint.template adds the parse tree of the supplied template if pressent and if possible else uses the default blueprints template. All reactive binding are automatically bounded to the view.
func (b *Blueprint) AndView(bind interface{}, vs *ViewStrategy, subt *template.Template) (Components, error) {
	return b.BuildAndView(bind, vs, subt, true)
}

// BuildView builds up a blueprint with the arguments, the name tag giving to the
// underline view is modded with the blueprint type name + a 5-length random string
// to make it unique in the state machines. It allows more control on whether to bind the given binding
// with the view if the binding is reactive
func (b *Blueprint) BuildView(bind interface{}, vs *ViewStrategy, bindBinding bool) Components {
	view := BuildReactiveView(fmt.Sprintf("%s:%s", b.Type(), flux.RandString(5)), b.format, vs, bind, bindBinding)
	return NewComponent(view)
}

// BuildAndView creates a new component with a combined template if supplied i.e the parsetree of the
// Blueprint.template adds the parse tree of the supplied template if pressent and if possible else uses the default blueprints template. It allows more control to decide if to bind the binding if its reactive
func (b *Blueprint) BuildAndView(bind interface{}, vs *ViewStrategy, subt *template.Template, bindBinding bool) (Components, error) {
	var sub *template.Template

	if subt != nil {
		so, err := b.format.AddParseTree(subt.Name(), subt.Tree)

		if err != nil {
			return nil, err
		}

		sub = so
	} else {
		sub = b.format
	}

	view := BuildReactiveView(fmt.Sprintf("%s:%s", b.Type(), flux.RandString(5)), sub, vs, bind, bindBinding)
	return NewComponent(view), nil
}

// Components defines the interface member rules for Blueprint instances aka Component
type Components interface {
	ReactiveViews
	Events() *EventManager
}

// component defines the concrete implmentation of a blueprint instance
type component struct {
	ReactiveViews
	events *EventManager
}

// NewComponent returns a new component instance
func NewComponent(v Views) Components {
	co := component{
		ReactiveViews: ReactView(v),
		events:        NewEventManager(),
	}

	return &co
}

// Events returns a EventManager used by the component
func (c *component) Events() *EventManager {
	return c.events
}
