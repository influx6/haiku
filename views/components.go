package views

import (
	"fmt"
	"html/template"

	"github.com/influx6/flux"
)

// Blueprints interface defines the interface for componet makers
type Blueprints interface {
	Construct(interface{}, *ViewStrategy) Components
	ConstructWith(bind interface{}, vs *ViewStrategy, subt *template.Template) (Components, error)
	Type() string
}

// Blueprint defines the component blueprint that it generates, like setting the
// building blocks that make up a components behaviour
type Blueprint struct {
	format  *template.Template
	bluetag string
}

// NewBlueprint returns a new blueprint instance
func NewBlueprint(id string, t *template.Template) *Blueprint {
	bp := Blueprint{
		format:  t,
		bluetag: id,
	}

	return &bp
}

// Type returns the tagname type of the components generated by this blueprint
func (b *Blueprint) Type() string {
	return b.bluetag
}

// Construct builds up a blueprint with the arguments, the name tag giving to the
// underline view is modded with the blueprint type name + a 5-length random string
// to make it unique in the state machines
func (b *Blueprint) Construct(bind interface{}, vs *ViewStrategy) Components {
	view := NewReactiveView(fmt.Sprintf("%s:%s", b.Type(), flux.RandString(5)), b.format, vs, bind)
	return NewComponent(view)
}

// ConstructWith creates a new component with a combined template if supplied i.e the parsetree of the
// Blueprint.template adds the parse tree of the supplied template if pressent and if possible else uses the default blueprints template
func (b *Blueprint) ConstructWith(bind interface{}, vs *ViewStrategy, subt *template.Template) (Components, error) {
	var sub *template.Template

	if subt != nil {
		so, err := b.format.AddParseTree(subt.Name(), subt.Tree)

		if err != nil {
			return nil, err
		}

		sub = so
	} else {
		sub = b.format
	}

	view := NewReactiveView(fmt.Sprintf("%s:%s", b.Type(), flux.RandString(5)), sub, vs, bind)
	return NewComponent(view), nil
}

// Components defines the interface member rules for Blueprint instances aka Component
type Components interface {
	ReactiveViews
	Events() *EventManager
}

// component defines the concrete implmentation of a blueprint instance
type component struct {
	ReactiveViews
	events *EventManager
}

// NewComponent returns a new component instance
func NewComponent(v Views) Components {
	co := component{
		ReactiveViews: ReactView(v),
		events:        NewEventManager(),
	}

	return &co
}

// Events returns a EventManager used by the component
func (c *component) Events() *EventManager {
	return c.events
}
