package views

import (
	"github.com/influx6/haiku/trees"
	"github.com/influx6/haiku/trees/elems"
)

// TreeView provides a pure trees.Markup based view system ontop of the base view allowing creation of views entirely using the trees.Markup structures
type TreeView struct {
	Views
	markup trees.SearchableMarkup
}

// TreeMux defines a handler for a treeView that lets you buildup the views
// Markup whilst still assessing the view.View function comfortably
type TreeMux func(Views) trees.SearchableMarkup

// NewTreeView returns a new TreeView instance if no TreeMux handle is supplied it uses a Div element as default or in case you return a nil dom tree
func NewTreeView(tag string, strategy Strategy, binding interface{}, mux TreeMux) *TreeView {
	//the view this tree uses underneath
	view := NewView(tag, strategy, binding)

	//the dom tree we want to use for building up
	var dom trees.SearchableMarkup

	if mux != nil {
		//lets get the dom from the handler
		dom = mux(view)

		//if still nil ,switch to default div node
		if dom == nil {
			dom = elems.Div()
		}
	} else {
		//no handler so straight to default div
		dom = elems.Div()
	}

	return &TreeView{
		Views:  view,
		markup: dom,
	}
}

// UseTreeView uses a predefined dom tree to create a TreeView
func UseTreeView(dom trees.SearchableMarkup, tag string, strategy Strategy, binding interface{}) *TreeView {
	return NewTreeView(tag, strategy, binding, func(v Views) trees.SearchableMarkup {
		return dom
	})
}

// DOM overrides the default DOM() method to return the user defined dom tree
func (t *TreeView) DOM() trees.SearchableMarkup {
	return t.markup
}

// DOMDisplayStrategy provides a simple "display:none" strategy for domtrees
func DOMDisplayStrategy(w trees.MarkupWriter) Strategy {
	return NewViewStrategy(w, func(v Views) trees.Markup {
		dom := v.DOM()

		if ds, err := dom.GetStyle("display"); err == nil {
			ds.Value = "block"
		}

		return dom
	}, func(v Views) trees.Markup {
		dom := v.DOM()

		if ds, err := dom.GetStyle("display"); err == nil {
			ds.Value = "none"
		}

		return dom
	})
}

// TreeBlueprint defines the component blueprint its uses to generate composed based on the TreeView
type TreeBlueprint struct {
	tag  string
	tree trees.SearchableMarkup
}

// NewTreeBlueprint returns a new blueprint object for creating treeviews
func NewTreeBlueprint(id string, dom trees.SearchableMarkup) *TreeBlueprint {
	return &TreeBlueprint{
		tag:  id,
		tree: dom,
	}
}

// Type returns the tagname type of the components generated by this blueprint
func (b *TreeBlueprint) Type() string {
	return b.tag
}

// View returns a new Component using the underline TreeView derivative, if `dobind` is true then it binds the reactive binding with the view. The blueprint's dom tree is cloned
func (b *TreeBlueprint) View(bind interface{}, vs Strategy, dobind bool) Components {
	view := ReactView(NewTreeView(MakeBlueprintName(b), vs, bind, func(v Views) trees.SearchableMarkup {
		return trees.GetSearchable(b.tree.Clone())
	}), dobind)
	return NewComponent(view, dobind)
}
