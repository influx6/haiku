package views

import (
	"strings"

	"github.com/influx6/haiku/trees"
)

// TreeView provides a pure trees.Markup based view system ontop of the base view allowing creation of views entirely using the trees.Markup structures
type TreeView struct {
	ReactiveViews
	markup trees.SearchableMarkup
}

// TreeMux defines a handler for a treeView that lets you buildup the views
// Markup whilst still assessing the view.View function comfortably
type TreeMux func(Views) trees.SearchableMarkup

// NewTreeView returns a new TreeView instance if no TreeMux handle is supplied it uses a element with the tagname as default or in case you return a nil dom tree
func NewTreeView(tag string, strategy Strategy, binding interface{}, mux TreeMux, dobind bool) *TreeView {
	//the view this tree uses underneath
	view := ReactView(NewView(tag, strategy, binding), dobind)

	var tagname string

	tags := strings.Split(tag, ":")

	if len(tags) > 1 {
		tagname = tags[0]
	} else {
		tagname = tag
	}

	//the dom tree we want to use for building up
	var dom trees.SearchableMarkup

	if mux != nil {
		//lets get the dom from the handler
		dom = mux(view)

		//if still nil ,switch to default div node
		if dom == nil {
			dom = trees.NewElement(tagname, false)
		}
	} else {
		//no handler so straight to default div
		dom = trees.NewElement(tagname, false)
	}

	view.switchDOM(dom)

	return &TreeView{
		ReactiveViews: view,
		markup:        dom,
	}
}

// UseTreeView uses a predefined dom tree to create a TreeView
func UseTreeView(dom trees.SearchableMarkup, tag string, strategy Strategy, binding interface{}, dobind bool) *TreeView {
	return NewTreeView(tag, strategy, binding, func(v Views) trees.SearchableMarkup {
		return dom
	}, dobind)
}

// DOMDisplayStrategy provides a simple "display:none" strategy for domtrees
func DOMDisplayStrategy(w trees.MarkupWriter) Strategy {
	return NewViewStrategy(w, func(v Views) trees.Markup {
		dom := v.DOM()

		if ds, err := dom.GetStyle("display"); err == nil {
			if strings.Contains(ds.Value, "none") {
				ds.Value = "block"
			}
		}

		return dom
	}, func(v Views) trees.Markup {
		dom := v.DOM()

		if ds, err := dom.GetStyle("display"); err == nil {
			ds.Value = "none"
		}

		return dom
	})
}

// TreeBlueprint defines the component blueprint its uses to generate composed based on the TreeView
type TreeBlueprint struct {
	tag  string
	tree trees.SearchableMarkup
}

// NewTreeBlueprint returns a new blueprint object for creating treeviews
func NewTreeBlueprint(id string, dom trees.SearchableMarkup) *TreeBlueprint {
	return &TreeBlueprint{
		tag:  id,
		tree: dom,
	}
}

// Type returns the tagname type of the components generated by this blueprint
func (b *TreeBlueprint) Type() string {
	return b.tag
}

// TreeBlueprintMux defines a handler for a treeView that lets you buildup the views
type TreeBlueprintMux func(Views, trees.SearchableMarkup) trees.SearchableMarkup

// CreateComponent returns a new component using CreateComponent
func (b *TreeBlueprint) CreateComponent(bind interface{}, vs Strategy, dobind bool, mx TreeBlueprintMux) Components {
	return CreateComponent(MakeBlueprintName(b), bind, vs, func(v Views) trees.SearchableMarkup {
		cl := trees.GetSearchable(b.tree.Clone())
		if mx != nil {
			return mx(v, cl)
		}
		return cl
	}, dobind)
}

// Create returns a new Component using the default DOMDisplayStrategy
func (b *TreeBlueprint) Create(bind interface{}, dobind bool) Components {
	return b.CreateComponent(bind, nil, dobind, nil)
}

// CreateComponent returns a new Component using the underline TreeView derivative, if `dobind` is true then it binds the reactive binding with the view. The blueprint's dom tree is cloned
func CreateComponent(name string, bind interface{}, vs Strategy, mx TreeMux, dobind bool) Components {
	//no strategy is supplid,create one
	if vs == nil {
		vs = DOMDisplayStrategy(trees.SimpleMarkupWriter)
	}

	view := NewTreeView(name, vs, bind, mx, dobind)
	return NewComponent(view)
}
